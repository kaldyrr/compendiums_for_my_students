# Конспект по Python (комбинированный формат)

_Краткие объяснения + мини‑примеры кода для каждой темы._

## Тема 1. Языки программирования. Развитие языков программирования. Обзор языков программирования. Жизненный цикл программы. Основные этапы решения задач на компьютере. Типы данных.

Коротко:
- ЯП эволюционировали от машинных и ассемблеров к высокоуровневым (C, Python) и доменно-ориентированным.
- Python — интерпретируемый, динамически типизируемый, мультипарадигменный (процедурный, ООП, функциональный).
- Жизненный цикл программы: постановка задачи → проектирование → кодирование → тестирование → внедрение → сопровождение.
- Этапы решения задач: анализ условия → модель/алгоритм → реализация → проверка/отладка → документирование.
- Базовые типы Python: int, float, bool, str, bytes, NoneType; коллекции: list, tuple, dict, set.

Мини‑пример (конец-начало цикла разработки: черновик → проверка):    
```python
def mean(xs: list[float]) -> float:
    return sum(xs)/len(xs) if xs else 0.0

assert mean([1,2,3]) == 2.0
```

## Тема 2. Практическое занятие. Знакомство со средой программирования.

Коротко:
- IDE/редакторы: VS Code, PyCharm; интерактив: REPL/`python`, Jupyter.
- Виртуальные окружения: `python -m venv .venv && source .venv/bin/activate`.
- Запуск: `python main.py`, отладка через breakpoints.

Мини‑пример: печать версии и «Hello»
```python
import sys
print(sys.version)
print("Hello, Python!")
```

## Тема 4. Программа.

Коротко:
- Программа в Python — набор модулей/скриптов с функциями и классами.
- Точка входа: блок `if __name__ == "__main__":`.
- Стиль: PEP 8, типы (PEP 484), документация (docstring).

Мини‑пример структуры:
```python
def run():
    print("Приложение")

if __name__ == "__main__":
    run()
```

## Тема 5. Этапы решения задач.

Коротко:
1) Анализ требований → 2) Проектирование (данные/алгоритмы) → 3) Код → 4) Тесты → 5) Ревью → 6) Деплой → 7) Поддержка.
Инструменты: диаграммы, псевдокод, прототипы, unit‑тесты.

Мини‑пример юнит‑теста (pytest):
```python
def add(a,b): return a+b

def test_add():
    assert add(2,3)==5
```

## Тема 6. Типы данных. Простые и производные типы.

Коротко:
- Простые: int, float, bool, str, bytes.
- Производные (составные): list, tuple, dict, set; user‑defined (классы/dataclasses).
- Неизменяемые: int, float, bool, str, tuple, frozenset. Изменяемые: list, dict, set.

Мини‑пример:
```python
user = {"name":"Ann","age":30,"skills":["py","sql"]}
```

## Тема 7. Операторы. Операции и выражения. Правила вычисления.

Коротко:
- Арифметика: + - * / // % **; сравнения: < <= == != >= >; логика: and or not.
- Присваивание: =, комбинированные (+= и т.п.), распаковка.
- Приоритет/скобки, ленивое вычисление `and`/`or`.

Мини‑пример:
```python
x = 2 + 3*4      # 14
ok = (x > 10) and (x < 20)  # True
a,b = 1,2
a,b = b,a        # swap
```

## Тема 8. Условный оператор.

Коротко:
- `if/elif/else` управляет ветвлением.
- Тернарный оператор: `x if cond else y`.
- Сопоставление с образцом (3.10+): `match/case`.

Мини‑пример:
```python
x = -3
sign = "pos" if x>0 else ("zero" if x==0 else "neg")
```

## Тема 9. Циклы.

Коротко:
- `for` по итерируемым объектам; `while` — по условию.
- Управление: `break`, `continue`, `else` у цикла.
- Генераторы списков/множеств/словарей.

Мини‑пример:
```python
for i in range(3):
    print(i)
else:
    print("готово")
```

## Тема 10. Массивы.

Коротко:
- В Python «массив» = список `list`; для чисел — `array` или `numpy.ndarray` (быстро).
- Индексация с 0, срезы `a[i:j:k]`.
- Вставка/удаление: `append`, `extend`, `insert`, `pop`, `remove`.

Мини‑пример:
```python
a = [10,20,30]
a.append(40); a[1:3] = [21,31]
```

## Тема 11. Практика: обработка одномерных массивов.

Задачи: сумма, максимум, фильтрация, мап/редьюс.
```python
xs = [1,3,2,5]
s = sum(xs)
mx = max(xs)
evens = [x for x in xs if x%2==0]
```

## Тема 12. Практика: обработка двумерных массивов.

Списки списков или `numpy`. Перебор по строкам/столбцам.
```python
m = [[1,2],[3,4]]
col1 = [row[0] for row in m]
```

## Тема 13. Практика: строки.

Строки неизменяемы; методы: `split`, `join`, `strip`, `replace`, `find`.
```python
s = "a,b, c "
parts = [p.strip() for p in s.split(",")]
t = "-".join(parts)  # 'a-b-c'
```

## Тема 14. Множества.

Уникальные элементы, быстрая проверка принадлежности.
Операции: `| & - ^`, методы: `add`, `remove`, `discard`.
```python
A = {1,2,3}; B = {3,4}
print(A|B, A&B, A-B, A^B)
```

## Тема 15. Практика: данные типа множество.

Пример: дедупликация и пересечение.
```python
emails = ["a@ex", "b@ex", "a@ex"]
uniq = set(emails)          # {'a@ex','b@ex'}
common = set("abracadabra") & set("bar")
```

## Тема 16. Практика: операции над множествами.

```python
need = {"milk", "bread", "eggs"}
cart = {"bread", "eggs", "cheese"}
missing = need - cart       # {'milk'}
extra = cart - need         # {'cheese'}
```

## Тема 17. Записи и файлы.

Записи = структуры данных (dict/dataclass). Файлы: текст/бинарные.
Режимы: 'r', 'w', 'a', 'b', менеджер контекста `with`.
```python
from dataclasses import dataclass
@dataclass
class User: name:str; age:int
with open("out.txt","w", encoding="utf-8") as f:
    f.write("hello")
```

## Тема 18. Практика: файлы последовательного доступа.

Чтение/запись построчно.
```python
with open("data.csv", encoding="utf-8") as f:
    for line in f:
        cols = line.rstrip().split(",")
```

## Тема 19. Практика: файлы прямого доступа.

Используйте `seek`/`tell` для позиционирования.
```python
with open("bin.dat","rb") as f:
    f.seek(10)
    chunk = f.read(4)
```

## Тема 20. Практика: типизированные файлы.

В Python типизация динамическая; «типизированность» можно эмулировать структурами (dataclass) + `pickle`/`struct`.
```python
import struct
with open("nums.bin","wb") as f:
    f.write(struct.pack("iii", 1,2,3))
```

## Тема 21. Практика: нетипизированные файлы.

Произвольный формат — контролируется вашим протоколом (например, CSV/JSON).
```python
import json
with open("user.json","w", encoding="utf-8") as f:
    json.dump({"name":"Ann"}, f, ensure_ascii=False)
```

## Тема 22. Процедуры и функции.

Функции — блоки переиспользуемого кода; параметры/возврат; аннотации типов.
```python
def area(w:float,h:float)->float: return w*h
```

## Тема 23. Практика: определение подпрограмм.

Именованные и лямбда‑функции.
```python
def apply(xs, f): return [f(x) for x in xs]
print(apply([1,2,3], lambda x: x*x))
```

## Тема 24. Практика: вызов подпрограмм.

Позиционные/именованные аргументы, значения по умолчанию, `*args/**kwargs`.
```python
def greet(name, punct="!"): print(f"Hi, {name}{punct}")
greet("Ann", punct="!!!")
```

## Тема 25. Практика: организация процедур и функций.

Разбивайте по модулям, сокращайте связность, повышайте связность внутри.
```python
# utils/mathx.py
def clamp(x, lo, hi): return max(lo, min(x, hi))
```

## Тема 26. Практика: передача параметров.

Передача по объектной ссылке; изменяемые аргументы могут меняться.
```python
def push(xs, v): xs.append(v)
a=[]; push(a,1)  # a изменился
```

## Тема 27. Практика: организация функций (ещё).

Чистые функции легче тестировать; побочные эффекты — на границах.
```python
def normalized(xs):
    total = sum(xs) or 1
    return [x/total for x in xs]
```

## Тема 28. Рекурсия.

Функция вызывает сама себя; базовый случай + шаг рекурсии; глубина ограничена.
```python
def fact(n): return 1 if n<=1 else n*fact(n-1)
```

## Тема 29. Практика: рекурсивные функции.

Пример: обход дерева.
```python
def walk(node):
    yield node.value
    for child in node.children:
        yield from walk(child)
```

## Тема 30. Практика: библиотека подпрограмм.

Структурируйте пакет: `__init__.py`, подмодули, тесты.
```python
# mylib/__init__.py
from .mathx import clamp
```

## Тема 31. Практика: указатели и связанные списки.

В Python нет «сырых» указателей; ссылки — автоматически. Связанный список через объекты.
```python
class Node:
    def __init__(self, val, nxt=None):
        self.val, self.next = val, nxt
```

## Тема 32. Практика: алгоритмы рекурсии.

Ханойские башни/поиск в глубину.
```python
def dfs(graph, v, seen=None):
    seen = seen or set(); seen.add(v)
    for u in graph[v]:
        if u not in seen: dfs(graph, u, seen)
    return seen
```

## Тема 33. Структуризация и структурное программирование.

Принципы: последовательность, ветвление, цикл; избегать goto; разбиение на модули/функции; инварианты/контракты.

## Тема 34. Практика: линейная структура.

```python
x = input("Введите имя: ")
print("Привет,", x)
```

## Тема 35. Практика: разветвляющаяся структура.

```python
age = int(input())
print("взрослый" if age>=18 else "несовершеннолетний")
```

## Тема 36. Практика: циклическая структура.

```python
total = 0
for _ in range(5):
    total += int(input())
print(total)
```

## Тема 37. Модульное программирование. Понятие модуля. Компоновка. Стандартные модули.

Модуль = файл `.py`; пакет = каталог с `__init__.py`. Импорт/переиспользование, сборка = установка зависимостей, упаковка (pip).
Популярные стандартные модули: `math`, `random`, `datetime`, `pathlib`, `json`, `re`, `itertools`.
```python
from pathlib import Path
print(Path.cwd())
```

## Тема 38. Практика: программирование модуля.

```python
# stats.py
def mean(xs): return sum(xs)/len(xs)
def median(xs): 
    xs=sorted(xs); n=len(xs); m=n//2
    return xs[m] if n%2 else (xs[m-1]+xs[m])/2
```

## Тема 39. Практика: программирование приложений.

CLI‑приложение с argparse.
```python
# app.py
import argparse
p=argparse.ArgumentParser()
p.add_argument("--name", default="World")
args=p.parse_args()
print(f"Hello, {args.name}")
```

## Тема 40. Указатели и динамическая память.

Python управляет памятью сам (GC, подсчёт ссылок). Для слабых ссылок: `weakref`.
```python
import weakref
```

## Тема 41. Структуры данных на основе указателей.

Деревья/графы строятся из объектов с ссылками.
```python
class Tree: 
    def __init__(self,val,children=None):
        self.val=val; self.children=children or []
```

## Тема 42. История ООП.

От Simula/Smalltalk → C++/Java/Python. ООП добавляет объекты, классы, инкапсуляцию.

## Тема 43. ООП: базовые понятия и принципы.

Объект/класс/интерфейс (в Python — ABC). Инкапсуляция, наследование, полиморфизм.
```python
from abc import ABC, abstractmethod
class Shape(ABC):
    @abstractmethod
    def area(self): ...
class Rect(Shape):
    def __init__(self,w,h): self.w,self.h=w,h
    def area(self): return self.w*self.h
```

## Тема 44. Классы объектов.

Конструктор `__init__`, методы/атрибуты, `__repr__`.
```python
class User:
    def __init__(self,name): self.name=name
    def __repr__(self): return f"User({self.name!r})"
```

## Тема 45. Практика: компоненты для работы с текстом.

Консоль: обработка текста, либо GUI (tkinter).
```python
text = input("Введите текст: ")
print(text.upper())
```

## Тема 46. Практика: ввод и отображение чисел, дат и времени.

```python
from datetime import datetime
n = float(input("Число: "))
print(f"{n:.2f}")
print(datetime.now().strftime("%Y-%m-%d %H:%M"))
```

## Тема 47. Практика: события компонентов (элементов управления).

В Tkinter события — коллбеки.
```python
import tkinter as tk
root=tk.Tk()
btn=tk.Button(root,text="Click", command=lambda: print("Hi"))
btn.pack(); root.mainloop()
```

## Тема 48. Практика: назначение элементов управления.

Поля ввода, кнопки, метки, списки — для взаимодействия пользователя с программой.

## Тема 49. Практика: классы ООП: виды, назначение.

Пользовательские классы, абстрактные базовые, миксины, dataclasses, enum.
```python
from dataclasses import dataclass
@dataclass
class Point: x:int; y:int
```

## Тема 50. Практика: классы ООП: свойства, методы.

Свойства через `@property`.
```python
class Celsius:
    def __init__(self,t): self._t=t
    @property
    def t(self): return self._t
    @t.setter
    def t(self,v): 
        if v<-273.15: raise ValueError
        self._t=v
```

## Тема 51. Практика: классы ООП: события.

Паттерн «наблюдатель».
```python
class Event:
    def __init__(self): self.handlers=[]
    def subscribe(self,h): self.handlers.append(h)
    def fire(self,*a,**k):
        for h in self.handlers: h(*a,**k)
```

## Тема 52. Практика: объявления класса.

Инициализация, dunder‑методы: `__str__`, `__eq__`, `__lt__`, `__hash__`.

## Тема 53. Практика: создание наследованного класса.

```python
class Animal: 
    def speak(self): return "..."

class Dog(Animal):
    def speak(self): return "woof"
```

## Тема 54. Событийно‑управляемая модель программирования.

UI/сервер реагирует на события (клики, запросы). Цикл обработки событий, коллбеки/обработчики, async‑модель.

## Тема 55. Интегрированная среда разработчика. Требования.

IDE (PyCharm/VS Code): подсветка, отладка, тесты, профилировка. Аппаратные требования умеренные, Python лёгкий.

## Тема 56. Практика: изучение IDE.

Создайте проект, настройте интерпретатор, включите линтер/форматтер (ruff/black).

## Тема 57. Интерфейс среды разработчика.

Файловое дерево, редактор, терминал, отладчик, тест‑раннер, панель расширений.

## Тема 58. Панель компонентов.

В контексте GUI (Tkinter/Qt): виджеты — кнопки, поля, таблицы; перетаскивание в визуальных конструкторах.

## Тема 59. Состав и характеристика проекта.

Структура: `src/`, `tests/`, `pyproject.toml`, `README.md`. Зависимости: `pip`, `uv`/`pip-tools`.

## Тема 60. Настройка среды и параметров.

Интерпретатор/venv, форматтер (black), линтер (ruff), типизация (mypy), тесты (pytest).

## Тема 61. Визуальное событийно-управляемое программирование. Компоненты.

Tkinter/Qt/Kivy. Основные элементы: `Button`, `Entry`, `Label`, `Listbox`, меню, диалоги.

## Тема 62. Дополнительные элементы управления.

Слайдеры, даты/календарь, ползунки прогресса, вкладки, Canvas/графика.

## Тема 63. События компонентов.

Привязка `<Button-1>`, `<KeyPress>`, и т.п.; обработчики получают объект события.

## Тема 64. Практика: процедуры на основе событий.

```python
def on_key(event):
    print("key:", event.char)
widget.bind("<Key>", on_key)
```

## Тема 65. Практика: кнопочные компоненты; диалоги и меню.

```python
import tkinter as tk
from tkinter import filedialog, messagebox
root=tk.Tk()
def open_file(): messagebox.showinfo("Файл", filedialog.askopenfilename())
m=tk.Menu(root); root.config(menu=m)
fm=tk.Menu(m, tearoff=0); fm.add_command(label="Открыть", command=open_file); m.add_cascade(label="Файл", menu=fm)
tk.Button(root,text="OK").pack(); root.mainloop()
```

## Тема 66. Практика: диалоги и меню (ещё).

Системные диалоги: открытие/сохранение, выбор цвета/шрифта; контекстные меню.

## Тема 67. Практика: обработка событий.

Декуплируйте логику от UI: обработчик вызывает сервис‑слой.

## Тема 68. Практика: компиляция и запуск приложения.

Python не компилируется в отдельные бинарники по умолчанию; упаковка: `pyinstaller`, `briefcase`.

## Тема 69. Разработка оконного приложения. Интерфейс.

Проектируйте сценарии пользователя, макеты (grid/pack), доступность (a11y), клавиатурные сокращения.

## Тема 70. Практика: приложение с несколькими формами.

Окна/диалоги как классы; навигация между окнами.

## Тема 71. Разработка функциональной схемы.

Блок‑схемы/диаграммы состояний, события → переходы → действия.

## Тема 72. Практика: функциональная схема работы приложения.

Опишите состояния (Idle/Loading/Error) и переходы; реализуйте через контроллер/машину состояний.

## Тема 73. Разработка игрового приложения.

Игровой цикл: обработка ввода → обновление состояния → отрисовка (pygame).

## Тема 74. Практика: игровое приложение.

Мини‑пример (pygame, концептуально): игровой цикл 60 FPS, спрайты, столкновения.

## Тема 75. Этапы разработки приложений. Проектирование ОО‑приложения. UI, отладка.

От ТЗ и UX‑прототипов к архитектуре (слои/паттерны), реализация, тесты, профилировка, релиз.

## Тема 76. Проектирование приложения.

Выберите архитектуру: MVC/MVP/MVVM, слои (UI/сервис/данные), границы и контракты.

## Тема 77. Создание интерфейса.

Каркас → визуальные компоненты → обработчики; адаптация к размерам окна; горячие клавиши.

## Тема 78. Практика: разработка интерфейса.

Стили/темы, таб‑порядок, фокус, валидация ввода.

## Тема 79. Тестирование и отладка.

Виды тестов: unit/integration/e2e; инструменты: pytest, coverage; отладчик: `pdb`, IDE.

## Тема 80. Практика: тестирование.

```python
import pytest
@pytest.mark.parametrize("a,b,res", [(2,3,5),(0,0,0)])
def test_add(a,b,res):
    assert a+b==res
```

## Тема 81. Практика: отладка.

Точки остановки, просмотр переменных; логирование: `logging`.
```python
import logging; logging.basicConfig(level=logging.INFO)
logging.info("started")
```

## Тема 82. Иерархия классов. Перегрузка методов. Тестирование и отладка.

Иерархии для полиморфизма; перегрузка операторов через dunder‑методы.
```python
class Vec:
    def __init__(self,x,y): self.x,self.y=x,y
    def __add__(self, o): return Vec(self.x+o.x, self.y+o.y)
```

## Тема 83. Практика: перегрузка методов.

```python
class Money:
    def __init__(self, amt): self.amt=amt
    def __mul__(self,k): return Money(self.amt*k)
    def __repr__(self): return f"{self.amt:.2f}"
```

## Тема 84. Решение задач при тестировании и отладке.

Стратегии: минимальные воспроизводимые примеры, бинарный поиск по коммитам, property‑based тесты (hypothesis).

## Тема 85. Практическое занятие: решение задач при тестировании и отладке приложения.

Соберите набор кейсов: корректные, пограничные, некорректные; автоматизируйте в CI.
